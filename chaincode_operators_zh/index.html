<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="Hyperledger国际化工作组">
  
  <title>Chaincode 操作手册 - Hyperledger中文文档</title>
  

  <link rel="shortcut icon" href="../img/favicon.ico">

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../css/highlight.css">

  
  <script>
    // Current page data
    var mkdocs_page_name = "Chaincode 操作手册";
    var mkdocs_page_input_path = "chaincode_operators_zh.md";
    var mkdocs_page_url = "/chaincode_operators_zh/";
  </script>
  
  <script src="../js/jquery-2.1.1.min.js"></script>
  <script src="../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../js/highlight.pack.js"></script>
  <script src="../js/theme.js"></script> 

  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Hyperledger中文文档</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        <ul class="current">
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="..">欢迎</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../glossary/">词汇表</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../getting_started/">快速入门</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../protocol-spec_zh/">协议规范</a>
        
    </li>
<li>
          
            <li>
    <ul class="subnav">
    <li><span>Fabric教程</span></li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../build_network_zh/">构建第一个fabric网络</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../write_first_app_zh/">编写第一个应用</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../chaincode_zh/">Chaincode 指南</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../chaincode_developers_zh/">Chaincode 开发手册</a>
        
    </li>

        
            
    <li class="toctree-l1 current">
        <a class="current" href="./">Chaincode 操作手册</a>
        
            <ul>
            
                <li class="toctree-l3"><a href="#chaincode">Chaincode 操作手册</a></li>
                
                    <li><a class="toctree-l4" href="#chaincode_1">什么是Chaincode？</a></li>
                
                    <li><a class="toctree-l4" href="#chaincode_2">Chaincode生命周期</a></li>
                
                    <li><a class="toctree-l4" href="#packaging">打包（Packaging）</a></li>
                
            
            </ul>
        
    </li>

        
    </ul>
<li>
          
            <li>
    <ul class="subnav">
    <li><span>Fabric操作指南</span></li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../msp_zh/">MSP</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../configtx_zh/">Channel 配置(configtx)</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../configtxgen_zh/">Channel 配置(configtxgen)</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../configtxlator_zh/">Channel 重新配置(configtxlator)</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../endorsement-policies_zh/">背书策略</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../error-handling_zh/">错误处理</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../logging-control_zh/">日志控制</a>
        
    </li>

        
    </ul>
<li>
          
            <li>
    <ul class="subnav">
    <li><span>Fabric设计</span></li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../arch-deep-dive_zh/">架构说明</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../txflow_zh/">交易流程</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../ca-setup_zh/">CA</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../sdk_node_zh/">SDK--node</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../sdk_java_zh/">SDK--java</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../kafka_zh/">基于kafka的排序服务</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../channels_zh/">Channels</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../ledger_zh/">账本</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../read-write-set/">Read-Write set</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../gossip_zh/">Gossip数据传输协议</a>
        
    </li>

        
    </ul>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../msp_acl_zh/">MSP&ACL</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../sdk-design_zh/">Fabric SDK 设计</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../makefile_zh/">Makefile文件解析</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../blockchain-crypto-service-provider_zh/">BCCSP密码算法套件解析</a>
        
    </li>
<li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Hyperledger中文文档</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
        
          <li>Fabric教程 &raquo;</li>
        
      
    
    <li>Chaincode 操作手册</li>
    <li class="wy-breadcrumbs-aside">
      
        
          <a href="https://github.com/HyperledgerCN/hyperledgerDocs" class="icon icon-github"> Edit on GitHub</a>
        
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <table>
<thead>
<tr>
<th>原文</th>
<th>作者</th>
<th>审核修正</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://hyperledger-fabric.readthedocs.io/en/latest/chaincode4noah.html">原文</a></td>
<td>Bei Wang</td>
<td>Dinghao Liu</td>
</tr>
</tbody>
</table>
<h1 id="chaincode">Chaincode 操作手册<a class="headerlink" href="#chaincode" title="Permanent link">&para;</a></h1>
<h2 id="chaincode_1">什么是Chaincode？<a class="headerlink" href="#chaincode_1" title="Permanent link">&para;</a></h2>
<p>Chaincode是一段由Go语言编写（支持其他编程语言，如Java），并能实现预定义接口的程序。Chaincode运行在一个受保护的Docker容器当中，与背书节点的运行互相隔离。Chaincode可通过应用提交的交易对账本状态初始化并进行管理。</p>
<p>一段chaincode通常处理由网络中的成员一致认可的业务逻辑，故我们很可能用“智能合约”来代指chaincode。一段chiancode创建的（账本）状态是与其他chaincode互相隔离的，故而不能被其他chaincode直接访问。不过，如果是在相同的网络中，一段chiancode在获取相应许可后则可以调用其他chiancode来访问它的账本。</p>
<p>在接下来的章节中，我们会以一个区块链网络操作者：诺亚，的视角了解学习chaincode。考虑到诺亚的关注点，我们将聚焦chaincode生命周期相关的操作。具体而言，就是在一个区块链网络中，将打包、安装、实例化和升级chaincode的过程作为一种可操作的chaincode生命周期函数进行调用。</p>
<h2 id="chaincode_2">Chaincode生命周期<a class="headerlink" href="#chaincode_2" title="Permanent link">&para;</a></h2>
<p>Hyperledger Fabric API让我们可以与区块链网络中的各种节点（peer节点、orderer节点、MSP节点）进行交互，同时我们还能在背书节点上安装、实例化及升级chaincode。Hyperledger Fabric特定语言的SDK工具将Hyperledger Fabric API的细节抽象了出来，便利了应用的开发过程;当然它也能用于管理chaincode生命周期。除此之外，Hyperledger Fabric API可以直接由CLI（命令行）访问，这正是本文接下来要做的。</p>
<p>我们提供了四个管理chaincode生命周期的命令：<code>package</code>, <code>install</code>, <code>instantiate</code>,<code>upgrade</code>。在未来的版本中，我们正考虑添加<code>stop</code>和<code>start</code>交易的指令，以便能方便地停止与重启chaincode，而不用非要真正卸载它才行。在成功安装与实例化chaincode后，chaincode就处于运行状态，接着就可以用<code>invoke</code>交易指令来处理交易了。一段chaincode可以在安装后的任何时间被更新。</p>
<h2 id="packaging">打包（Packaging）<a class="headerlink" href="#packaging" title="Permanent link">&para;</a></h2>
<p>chaincode包具体包含以下三个部分：</p>
<ul>
<li>chaincode本身，其由<code>ChaincodeDeploymentSpec</code>或CDS定义。CDS根据代码及一些其他属性（名称，版本等）来定义chaincode。</li>
<li>一个可选的实例化策略，该策略可被 <strong><em>背书策略</em></strong> 描述。</li>
<li>一组表示chaincode所有权的签名。</li>
</ul>
<p>channel上chaincode实例化交易的创建者可被chaincode的实例化策略验证。</p>
<h3 id="_1">创建包<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h3>
<p>打包chaincode有两种方式。第一种是当你想要让chaincode有多个所有者的时候，此时就需要让chaincode包被多个所有者签名。这种情况下需要我们创建一个被签名的chaincode包（<code>SignedCDS</code>），这个包依次被每个所有者签名。</p>
<p>另一种就比较简单了，这是当你要建立只有一个节点的签名的时候（该节点执行<code>install</code>交易）。</p>
<p>我们先来看看更复杂的情况。当然，如果您对多用户的情况不感兴趣，您可以直接跳到后面的安装chaincode部分。</p>
<p>要创建一个签名过的chaincode包，请用下面的指令：</p>
<pre><code>peer chaincode package -n mycc -p github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02 -v 0 -s -S -i &quot;AND('OrgA.admin')&quot; ccpack.out
</code></pre>

<p><code>-s</code>选项创建了一个可被多个所有者签名的包，而非简单地创建一个CDS。如果使用<code>-s</code>，那么当其他所有者要签名的时候，<code>-S</code>也必须同时使用。否则，该过程将创建一个仅包含实例化策略的签名chaincode包（SignedCDS）。</p>
<p><code>-S</code>选项可以使在<code>core.yaml</code>文件中被<code>localMspid</code>相关属性值定义好的MSP对包进行签名。</p>
<p><code>-S</code>选项是可选的。不过，如果我们创建了一个没有签名的包，那么它就不能被任何其他所有者用<code>signpackage</code>指令进行签名。</p>
<p><code>-i</code>选项也是可选的，它允许我们为chaincode指定实例化策略。实例化策略与背书策略格式相同，它指明谁可以实例化chaincode。在上面的例子中，只有OrgA的管理员才有资格实例化chaincode。如果没有提供任何策略，那么系统会采用默认策略，该策略只允许peer节点MSP的管理员去实例化chaincode。</p>
<h3 id="_2">包的签名<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h3>
<p>一个在创建时就被签名的chaincode包可以交给其他所有者进行检查与签名。具体的工作流程支持带外对chaincode包签名。</p>
<p><strong><em>ChaincodeDeploymentSpec</em></strong> 可以选择被全部所有者签名并创建一个 <strong><em>SignedChaincodeDeploymentSpec</em></strong>（SignedCDS），SignedCDS包含三个部分：</p>
<ul>
<li>CDS包含chaincode的源码、名称与版本</li>
<li>一个chaincode实例化策略，其表示为背书策略</li>
<li>chaincode所有者的列表，由Endorsement定义</li>
</ul>
<p><strong><em>注意:</em></strong></p>
<p><em>注意，当chaincode在某些channel上实例化时，背书策略在带外定义，并提供合适的MSP。如果没有明确实例化策略，那么默认的策略是channel的任意管理员（执行实例化）</em></p>
<p>每个（chaincode的）所有者通过将ChaincodeDeploymentSpec与其本人的身份信息（证书）结合并对组合结果签名来认证ChaincodeDeploymentSpec。</p>
<p>一个chaincode所有者可以对一个之前创建好的带签名的包进行签名，具体使用如下指令：</p>
<pre><code class="bash">peer chaincode signpackage ccpack.out signedccpack.out
</code></pre>

<p>指令中的<code>ccpack.out</code>和<code>signedccpack.out</code>分别是输入与输出包。<code>signedccpack.out</code>则包含一个用本地MSP对包进行的附加签名。</p>
<h3 id="chaincode_3">安装chaincode<a class="headerlink" href="#chaincode_3" title="Permanent link">&para;</a></h3>
<p><code>install</code>交易的过程会将chaincode的源码以一种被称为<code>ChaincodeDeploymentSpec</code>（CDS）的规定格式打包，并把它安装在一个将要运行该chaincode的peer节点上。</p>
<p><strong><em>注意:</em></strong></p>
<p><em>请务必在一条channel上每一个要运行你chaincode的背书节点上安装你的chaincode</em></p>
<p>如果只是简单地给<code>install</code> API一个<code>ChaincodeDeploymentSpec</code>，它将使用默认实例化策略并添加一个空的所有者列表。</p>
<p><strong><em>注意:</em></strong></p>
<p><em>Chaincode应该仅仅被安装于chaincode所有者的背书节点上，以使该chaincode逻辑对整个网络的其他成员保密。其他没有chaincode的成员将无权成为chaincode影响下的交易的认证节点（endorser）。也就是说，他们不能执行chaincode。不过，他们仍可以验证交易并提交到账本上。</em></p>
<p>下面安装chaincode。此时会发送一条 <strong><em>SignedProposal</em></strong> 到<code>生命周期系统chaincode</code> (LSCC)，该chaincode在<strong><em>系统chaincode</em></strong>部分会仔细描述。举个例子，使用CLI安装<strong><em>简单的账本管理chaincode</em></strong>章节的sacc chaincode样例时，命令如下：</p>
<pre><code class="bash">peer chaincode install -n asset_mgmt -v 1.0 -p sacc
</code></pre>

<p>在CLI内部会为sacc创建SignedChaincodeDeploymentSpec，并将其发送到本地peer节点。这些节点会调用LSCC上的<code>Install</code>方法。上述的<code>-p</code>选项指明chaincode的路径，其必须在用户的<code>GOPATH</code>目录下（比如<code>$GOPATH/src/sacc</code>）。完整的命令选项详见<strong><em>CLI</em></strong>部分。</p>
<p>注意：为了在peer节点上安装（chaincode），SignedProposal的签名必须来自peer节点本地MSP的管理员中的一位。</p>
<h3 id="chaincode_4">实例化chaincode<a class="headerlink" href="#chaincode_4" title="Permanent link">&para;</a></h3>
<p>实例化交易会调用<code>生命周期系统chaincode</code> (LSCC)来在一个channel上创建并初始化一段chaincode。下面是一个chaincode-channel绑定的具体过程：一段chaincode可能会与任意数量的channel绑定并在每个channel上独立运行。换句话说，chaincode在多少个channel上安装并实例化并没有什么影响，对于每个提交交易的channel，其状态都是独立而互不影响的。</p>
<p>一个<code>实例化</code>交易的创建者必须符合在SignedCDS中chaincode的实例化策略，且必须充当channel的写入器（这会成为channel创建配置的一部分）。这对于channel的安全至关重要，因为这样可以防止恶意实体在未绑定的channel上部署chaincode，也能防止间谍成员在未绑定的channel上执行chaincode。</p>
<p>举个例子，我们提到过默认的实例化策略是任何channel MSP的管理员（可以执行），所以chaincode创建者要实例化交易，其本人必须是channel管理员的一员。当交易提议到达背书成员时，它会验证创建者的签名是否符合实例化策略。在交易被提交到账本之前的交易验证阶段，以上操作还会再来一遍。</p>
<p>实例化交易的过程还会为channel上的chaincode建立背书策略。背书策略描述了交易的相关认证要求，以使得交易能被channel中的成员认可。</p>
<p>例如，使用CLI去实例化上一章的sacc chaincode并初始化<code>john</code>的状态为<code>0</code>，指令具体如下：</p>
<pre><code class="bash">peer chaincode instantiate -n sacc -v 1.0 -c '{&quot;Args&quot;:[&quot;john&quot;,&quot;0&quot;]}' -P &quot;OR ('Org1.member','Org2.member')&quot;
</code></pre>

<p><strong><em>注意:</em></strong></p>
<p><em>注意，上述背书策略（CLI使用波兰表示法）向Org1或Org2的成员询问所有sacc处理的交易。也就是说，为确保交易有效，Org1或Org2必须为调用<strong>sacc</strong>的结果签名。</em></p>
<p>在成功实例化后，channel上的chaincode就进入激活状态，并时刻准备执行任何<strong><em>ENDORSER_TRANSACTION</em></strong>类型的交易提议。交易会在到达背书节点的同时被处理。</p>
<h3 id="chaincode_5">升级chaincode<a class="headerlink" href="#chaincode_5" title="Permanent link">&para;</a></h3>
<p>一段chaincode可以通过更改它的版本（SignedCDS的一部分）来随时进行更新。至于SignedCDS的其他部分，比如所有者及实例化策略，都是可选的。不过，chaincode的名称必须一致，否则它会被当做完全不同的另一段chaincode。</p>
<p>在升级之前，chaincode的新版本必须安装在需要它的背书节点上。升级是一个类似于实例化交易的交易，它会将新版本的chaincode与channel绑定。其他与旧版本绑定的channel则仍旧运行旧版本的chaincode。换句话说，<code>升级</code>交易只会一次影响一个提交它的channel。</p>
<p><strong><em>注意:</em></strong></p>
<p><em>注意：由于多个版本的chaincode可能同时运行，所以升级过程不会自动移除旧版本，用户必须亲自处理。</em></p>
<p><code>升级</code>交易与<code>实例化</code>交易有一处微妙的区别：<code>升级</code>交易采用当前的chaincode实例化策略进行检查，而非比对新的策略（如果指定了的话）。这是为了确保只有当前实例化策略指定的已有成员才能升级chaincode。</p>
<p><strong><em>注意:</em></strong></p>
<p><em>注意：在升级过程中，chaincode的<code>Init</code>函数会被调用以执行数据相关的操作，或者重新初始化数据；所以要多加小心避免在升级chaincode时重设状态信息。</em></p>
<h3 id="_3">停止与启动<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h3>
<p>注意，<code>停止</code>与<code>启动</code>生命周期交易的功能还没实现。不过，你可以通过移除chaincode容器以及从每个背书节点删除SignedCDS包来停止chaincode。具体而言，就是删除所有主机或虚拟机上peer节点运行于其中的chaincode的容器，随后从每个背书节点删除SignedCDS。</p>
<p><strong><em>注意:</em></strong></p>
<p><em>TODO -为了从peer节点删除CDS，你应该需要先进入peer节点的容器内。我们的确需要提供一个可以执行此功能的脚本</em></p>
<pre><code class="bash">docker rm -f &lt;container id&gt;
rm /var/hyperledger/production/chaincodes/&lt;ccname&gt;:&lt;ccversion&gt;
</code></pre>

<p>停止功能在以受控的方式进行升级的流程中将非常有用，特别是在进行升级前，一段channel上所有节点的chaincode都可被停止。</p>
<h3 id="cli">CLI<a class="headerlink" href="#cli" title="Permanent link">&para;</a></h3>
<p><strong><em>注意:</em></strong></p>
<p><em>我们正在评估为 Hyperledger Fabric <code>peer</code>的二进制文件拆分特定平台二进制文件的需求。不过目前，您可以在一个正在运行的docker容器中方便地调用指令。</em></p>
<p>下面我们将一览现在可用的CLI指令，请在一个运行<code>fabric-peer</code>的Docker容器中执行以下指令：</p>
<pre><code class="bash">docker run -it hyperledger/fabric-peer bash
# peer chaincode --help
</code></pre>

<p>我们将看到如下输出：</p>
<pre><code class="bash">Usage:
  peer chaincode [command]

Available Commands:
  install     Package the specified chaincode into a deployment spec and save it on the peer’s path.
  instantiate Deploy the specified chaincode to the network.
  invoke      Invoke the specified chaincode.
  package     Package the specified chaincode into a deployment spec.
  query       Query using the specified chaincode.
  signpackage Sign the specified chaincode package
  upgrade     Upgrade chaincode.

Flags:
      --cafile string     Path to file containing PEM-encoded trusted certificate(s) for the ordering endpoint
  -C, --chainID string    The chain on which this command should be executed (default &quot;testchainid&quot;)
  -c, --ctor string       Constructor message for the chaincode in JSON format (default &quot;{}&quot;)
  -E, --escc string       The name of the endorsement system chaincode to be used for this chaincode
  -l, --lang string       Language the chaincode is written in (default &quot;golang&quot;)
  -n, --name string       Name of the chaincode
  -o, --orderer string    Ordering service endpoint
  -p, --path string       Path to chaincode
  -P, --policy string     The endorsement policy associated to this chaincode
  -t, --tid string        Name of a custom ID generation algorithm (hashing and decoding) e.g. sha256base64
      --tls               Use TLS when communicating with the orderer endpoint
  -u, --username string   Username for chaincode operations when security is enabled
  -v, --version string    Version of the chaincode specified in install/instantiate/upgrade commands
  -V, --vscc string       The name of the verification system chaincode to be used for this chaincode

Global Flags:
      --logging-level string       Default logging level and overrides, see core.yaml for full syntax
      --test.coverprofile string   Done (default &quot;coverage.cov&quot;)

Use &quot;peer chaincode [command] --help&quot; for more information about a command.
</code></pre>

<p>为方便在脚本应用程序里使用，<code>peer</code>指令失败时总会返回一个非0值。</p>
<p>chaincode的指令示例如下：</p>
<pre><code class="bash">peer chaincode install -n mycc -v 0 -p path/to/my/chaincode/v0
peer chaincode instantiate -n mycc -v 0 -c '{&quot;Args&quot;:[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]}' -C mychannel
peer chaincode install -n mycc -v 1 -p path/to/my/chaincode/v1
peer chaincode upgrade -n mycc -v 1 -c '{&quot;Args&quot;:[&quot;d&quot;, &quot;e&quot;, &quot;f&quot;]}' -C mychannel
peer chaincode query -C mychannel -n mycc -c '{&quot;Args&quot;:[&quot;query&quot;,&quot;e&quot;]}'
peer chaincode invoke -o orderer.example.com:7050  --tls $CORE_PEER_TLS_ENABLED --cafile $ORDERER_CA -C mychannel -n mycc -c '{&quot;Args&quot;:[&quot;invoke&quot;,&quot;a&quot;,&quot;b&quot;,&quot;10&quot;]}'
</code></pre>

<h3 id="chaincode_6">系统chaincode<a class="headerlink" href="#chaincode_6" title="Permanent link">&para;</a></h3>
<p>系统chaincode与普通chaincode的编程模型相同，只不过它运行于peer节点内而非一个隔离的容器中。因此，系统chaincode在节点内构建且不遵循上文描述的chaincode生命周期。特别地，<strong><em>安装</em></strong>，<strong><em>实例化</em></strong>，<strong><em>升级</em></strong>这三项操作不适用于系统chaincode。</p>
<p>系统chaincode的目的是削减peer节点和chaincode之间的gRPC通讯成本，并兼顾管理的灵活性。例如：一个系统chaincode只能通过peer节点的二进制文件升级。同时，系统chaincode只能以一组编译好的特定的参数进行注册，且不具有背书策略相关功能。</p>
<p>系统chaincode在Hyperledger Fabric中用于实现一些系统行为，故它们可以被系统开发者适当替换或更改。</p>
<p>以下是系统chaincode的列表：</p>
<ul>
<li>LSCC：生命周期系统chaincode处理上述生命周期相关的功能</li>
<li>CSCC：配置系统chaincode处理peer侧channel的配置</li>
<li>QSCC：查询系统chaincode提供账本查询API，比如获取区块及交易等</li>
<li>ESCC：背书系统chaincode通过对交易响应进行签名来处理背书过程</li>
<li>VSCC：验证系统chaincode处理交易的验证，包括检查背书策略以及多版本并发控制</li>
</ul>
<p>替换或更改这些系统chaincode一定要万分小心，尤其是LSCC, ESCC 和 VSCC，因为它们处于主交易执行路径中。值得注意的是，VSCC在一个区块被提交到账本之前进行验证，故所有channel中的peer节点得出相同的验证结果以避免账本分叉（不确定因素）就很重要了。所以当VSCC被更改或替换时就要特别小心了。</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../msp_zh/" class="btn btn-neutral float-right" title="MSP">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../chaincode_developers_zh/" class="btn btn-neutral" title="Chaincode 开发手册"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
      <p>Hyperledger国际化工作组(yls@chainnova.com)</p>
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>

  </div>

<div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/HyperledgerCN/hyperledgerDocs" class="icon icon-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href="../chaincode_developers_zh/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../msp_zh/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>

</body>
</html>
