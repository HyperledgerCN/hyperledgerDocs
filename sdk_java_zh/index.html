<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="Hyperledger国际化工作组">
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>SDK--java - Hyperledger中文文档</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../css/highlight.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "SDK--java";
    var mkdocs_page_input_path = "sdk_java_zh.md";
    var mkdocs_page_url = "/sdk_java_zh/";
  </script>
  
  <script src="../js/jquery-2.1.1.min.js"></script>
  <script src="../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../js/highlight.pack.js"></script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Hyperledger中文文档</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="..">欢迎</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../glossary/">词汇表</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../getting_started/">快速入门</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../protocol-spec_zh/">协议规范</a>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Fabric教程</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../build_network_zh/">构建第一个fabric网络</a>
                </li>
                <li class="">
                    
    <a class="" href="../write_first_app_zh/">编写第一个应用</a>
                </li>
                <li class="">
                    
    <a class="" href="../chaincode_zh/">Chaincode</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Fabric操作指南</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../msp_zh/">MSP</a>
                </li>
                <li class="">
                    
    <a class="" href="../configtx_zh/">Channel 配置(configtx)</a>
                </li>
                <li class="">
                    
    <a class="" href="../configtxgen_zh/">Channel 配置(configtxgen)</a>
                </li>
                <li class="">
                    
    <a class="" href="../configtxlator_zh/">Channel 重新配置(configtxlator)</a>
                </li>
                <li class="">
                    
    <a class="" href="../endorsement-policies_zh/">背书策略</a>
                </li>
                <li class="">
                    
    <a class="" href="../error-handling_zh/">错误处理</a>
                </li>
                <li class="">
                    
    <a class="" href="../logging-control_zh/">日志控制</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Fabric设计</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../arch-deep-dive_zh/">架构说明</a>
                </li>
                <li class="">
                    
    <a class="" href="../txflow_zh/">交易流程</a>
                </li>
                <li class="">
                    
    <a class="" href="../ca-setup_zh/">CA</a>
                </li>
                <li class="">
                    
    <a class="" href="../sdk_node_zh/">SDK--node</a>
                </li>
                <li class=" current">
                    
    <a class="current" href="./">SDK--java</a>
    <ul class="subnav">
            
    <li class="toctree-l3"><a href="#known-limitations-and-restrictions">已知的限制(Known limitations and restrictions)</a></li>
    

    <li class="toctree-l3"><a href="#v100">v1.0.0</a></li>
    

    <li class="toctree-l3"><a href="#fabricfabric-cavalid-builds-of-fabric-and-fabric-ca">验证Fabric和Fabric-ca包(Valid builds of Fabric and Fabric-ca)</a></li>
    

    <li class="toctree-l3"><a href="#fabric-vagrantworking-with-the-fabric-vagrant-environment">使用Fabric Vagrant环境(Working with the Fabric Vagrant environment)</a></li>
    

    <li class="toctree-l3"><a href="#sdk-sdk-dependencies">SDK 依赖(SDK dependencies)</a></li>
    

    <li class="toctree-l3"><a href="#sdkusing-the-sdk">使用SDK(Using the SDK)</a></li>
    
        <ul>
        
            <li><a class="toctree-l4" href="#compiling">编译(Compiling)</a></li>
        
            <li><a class="toctree-l4" href="#running-the-unit-tests">执行单元测试(Running the unit tests)</a></li>
        
            <li><a class="toctree-l4" href="#running-the-integration-tests">执行集成测试(Running the integration tests)</a></li>
        
            <li><a class="toctree-l4" href="#end-to-end-test-scenario">端到端测试场景(End to end test scenario)</a></li>
        
            <li><a class="toctree-l4" href="#end-to-end-test-environment">端到端测试环境(End to end test environment)</a></li>
        
            <li><a class="toctree-l4" href="#tlsordererpeertls-connection-to-orderer-and-peers">通过TLS连接到Orderer和Peer(TLS connection to Orderer and Peers)</a></li>
        
            <li><a class="toctree-l4" href="#chaincode-endorsement-policies">链码背书策略(Chaincode endorsement policies)</a></li>
        
            <li><a class="toctree-l4" href="#channel-creation-artifacts">通道创建工件(Channel creation artifacts)</a></li>
        
            <li><a class="toctree-l4" href="#gogo-lang-chaincode">GO语言链码(GO Lang chaincode)</a></li>
        
        </ul>
    

    <li class="toctree-l3"><a href="#basic-troubleshooting">简单的问题解决(Basic Troubleshooting)</a></li>
    

    <li class="toctree-l3"><a href="#communicating-with-developers-and-fellow-users">和开发者交流(Communicating with developers and fellow users)</a></li>
    

    <li class="toctree-l3"><a href="#reporting-issues">报告问题(Reporting Issues)</a></li>
    

    </ul>
                </li>
                <li class="">
                    
    <a class="" href="../kafka_zh/">基于kafka的排序服务</a>
                </li>
                <li class="">
                    
    <a class="" href="../channels_zh/">Channels</a>
                </li>
                <li class="">
                    
    <a class="" href="../ledger_zh/">账本</a>
                </li>
                <li class="">
                    
    <a class="" href="../read-write-set/">Read-Write set</a>
                </li>
                <li class="">
                    
    <a class="" href="../gossip_zh/">Gossip数据传输协议</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../msp_acl_zh/">MSP&ACL</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../sdk-design_zh/">Fabric SDK 设计</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../makefile_zh/">Makefile文件解析</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Hyperledger中文文档</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
        
          <li>Fabric设计 &raquo;</li>
        
      
    
    <li>SDK--java</li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="https://github.com/HyperledgerCN/hyperledgerDocs/edit/master/docs/sdk_java_zh.md"
          class="icon icon-github"> Edit on GitHub</a>
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <p>| 原文 | 作者 | 审核修正 |
| &mdash; | &mdash; | —&mdash; |
| <a href="https://github.com/hyperledger/fabric-sdk-java">原文</a> | Xuanyong Wu |  |</p>
<p>Welcome to Java SDK for Hyperledger project. The SDK helps facilitate Java applications to manage the lifecycle of Hyperledger channels  and user chaincode. The SDK also provides a means to execute user chaincode, query blocks and transactions on the channel, and monitor events on the channel.</p>
<p>欢迎使用Hyperledger项目的Java SDK。 该SDK帮助促进Java应用程序对Hyperledger通道和用户链码的生命周期的管理。该SDK同时提供执行用户链码、在通道上查询区块和交易以及监听通道上的事件的一些方法。</p>
<p>The SDK acts on behave of a particular User which is defined by the embedding application through the implementation of the SDK&rsquo;s <code>User</code> interface.</p>
<p>该SDK能够实现一些特定用户的行为，这是由嵌入的应用程序通过实现SDK的<code>User</code>接口来完成的。</p>
<p>Note, the SDK does <strong><em>not</em></strong> provide a means of persistence for the application defined channels and user artifacts on the client. This is left for the embedding application to best manage.</p>
<p>请注意，该SDK<strong><em>不提供</em></strong>客户端上应用定义的通道和用户结果的持久性方法。这个是预留给嵌入程序能够进行更有效的管理。</p>
<p>The SDK also provides a client for Hyperledger&rsquo;s certificate authority.  The SDK is however not dependent on this
particular implementation of a certificate authority. Other Certificate authority&rsquo;s maybe used by implementing the
SDK&rsquo;s <code>Enrollment</code> interface.</p>
<p>该SDK同时提供一个连接Hyperledger证书机构的客户端。但该SDK并不依赖于这种连接证书机构的方法，用户也可以通过实现SDK的<code>Enrollment</code>接口来使用其他的证书机构。</p>
<p>This provides a summary of steps required to get you started with building and using the Java SDK. Please note that this is not the API documentation or a tutorial for the SDK, this will only help you familiarize to get started with the SDK if you are new in this domain.</p>
<p>以下步骤让你可以开始编译和使用Java SDK。
请注意，因为这个文档不是API文档或者SDK指南，所以仅仅帮助新手熟悉如何开始使用SDK。</p>
<h2 id="known-limitations-and-restrictions">已知的限制(Known limitations and restrictions)<a class="headerlink" href="#known-limitations-and-restrictions" title="Permanent link">&para;</a></h2>
<ul>
<li>TCerts are not supported(不支持TCerts): JIRA FAB-1401</li>
<li>HSM not supported(不支持HSM): JIRA FAB-3137</li>
<li>Single Crypto strength 256(单层加密长度为256位): JIRA FAB-2564</li>
<li>Network configuration updates not supported(不支持网络配置更新): JIRA FAB-3103</li>
</ul>
<p><code>*************************************************</code></p>
<h2 id="v100"><em>v1.0.0</em><a class="headerlink" href="#v100" title="Permanent link">&para;</a></h2>
<p>There is a git tagged v1.0.0 [e976abdc658f212d0c3a80ace4499a5cff4279c6] release of the SDK where there is no need to build the Hyperledger Fabric and Hyperledger Fabric CA described below. The provided docker-compose.yaml for the integration tests should pull v1.0.0  tagged images from Docker hub.</p>
<p>已经有一个标记为V1.0.0[e976abdc658f212d0c3a80ace4499a5cff4279c6]的SDK发行版，所以没有必要自己打包Hyperledge Fabric和Hyperledger Fabric CA。提供集成测试的docker-compose.yaml会自动从Docker Hub下载V1.0.0的镜像。</p>
<p>The v1.0.0 version of the Hyperledger Fabric Java SDK is published to Maven so you can directly use in your application&rsquo;s pom.xml.</p>
<p>V1.0.0的Hyperledger Fabric Java SDK已经发布到了Maven仓库，你可以直接在你的应用程序的pom.xml文件中直接使用。</p>
<p><a href="https://mvnrepository.com/artifact/org.hyperledger.fabric-sdk-java/fabric-sdk-java">Maven Repository Hyperledger Fabric Java SDK</a></p>
<p><em>Make sure you&rsquo;re using docker images at the level of the Fabric that matches the level of the SDK you&rsquo;re using in your application.</em></p>
<p><em>请确认你使用的docker镜像的版本和你应用程序中使用的SDK版本一致。</em></p>
<p><code>*************************************************</code></p>
<h2 id="fabricfabric-cavalid-builds-of-fabric-and-fabric-ca">验证Fabric和Fabric-ca包(Valid builds of Fabric and Fabric-ca)<a class="headerlink" href="#fabricfabric-cavalid-builds-of-fabric-and-fabric-ca" title="Permanent link">&para;</a></h2>
<p>Hyperledger Fabric v1.0.1 is currently under active development and the very latest Hyperledger Fabric builds may not work with this sdk.
You should use the following commit levels of the Hyperledger projects:</p>
<p>Hyperledger Fabric V1.0.1 正在开发中，最新的Fabric打包可能不适用该SDK，你应该使用下面提交版本的Hyledger项目。</p>
<table>
<thead>
<tr>
<th>Project</th>
<th align="center">Commit level</th>
<th align="right">Date</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>fabric</td>
<td align="center">f56a82e36e040e1c1a986edfceac014ba1516571</td>
<td align="right">Jul 11 12:48:33 2017 -0700</td>
<td></td>
</tr>
<tr>
<td>fabric-ca</td>
<td align="center">74f8f4d4c29e45a79a8849efb057dbd8de3ae8d0</td>
<td align="right">Jul 11 16:43:39 2017 +0200</td>
<td></td>
</tr>
</tbody>
</table>
<p>You can clone these projects by going to the <a href="https://gerrit.hyperledger.org/r/#/admin/projects/">Hyperledger repository</a>.</p>
<p>你可以到<a href="https://gerrit.hyperledger.org/r/#/admin/projects/">Hyperledger仓库</a>克隆这些项目。</p>
<p>As SDK development continues, this file will be updated with compatible Hyperledger Fabric and Fabric-ca commit levels.</p>
<p>随着SDK的开发进行中，这些文件将会随着Fabric和Fabric-ca的提交版本变化而更新。</p>
<p>Once you have cloned <code>fabric</code> and <code>fabric-ca</code>, use the <code>git reset --hard commitlevel</code> to set your repositories to the correct commit.</p>
<p>你克隆<code>fabric</code>和<code>fabric-ca</code>时，使用<code>git reset --hard commitlevel</code>来设置你仓库的使用正确的提交版本。</p>
<h2 id="fabric-vagrantworking-with-the-fabric-vagrant-environment">使用Fabric Vagrant环境(Working with the Fabric Vagrant environment)<a class="headerlink" href="#fabric-vagrantworking-with-the-fabric-vagrant-environment" title="Permanent link">&para;</a></h2>
<p>Vagrant is NOT required if your OS has Docker support and all the requirements needed to build directly in your
environment.  For non Vagrant envrionment, the steps would be the same as below minus those parts involving Vagrant.
 Do the following if you want to run the Fabric components ( peer, orderer, fabric-ca ) in Vagrant:</p>
<p>如果你的环境支持Docker，Vagrant不是必须的，你只需要你的环境中直接打包。在非Vagrant环境，牵涉到Vagrant的步骤会少许有些不同。
按照下面的步骤在Vagrant中运行Fabric组件( peer, orderer, fabric-ca )：</p>
<pre><code>  git clone  https://github.com/hyperledger/fabric.git
  git clone  https://github.com/hyperledger/fabric-ca.git
  cd  fabric-ca
  git reset --hard fabric-ca_commitlevel from above
  cd ../fabric
  git reset --hard fabric_commitlevel from above
  cd devenv
  change the Vagrant file as suggested below:
  vagrant up
  vagrant ssh
  make docker
  cd ../fabric-ca
  make docker
  cd ../fabric/sdkintegration
  docker-compose down;  rm -rf /var/hyperledger/*; docker-compose up --force-recreate
</code></pre>

<ul>
<li>Open the file <code>Vagrantfile</code> and verify that the following <code>config.vm.network</code> statements are set. If not, then add them:</li>
<li>打开<code>Vagrantfile</code>文件来验证下面的<code>config.vm.network</code>参数是否设置了，如果没有，请添加以下行。</li>
</ul>
<pre><code>  config.vm.network :forwarded_port, guest: 7050, host: 7050 # fabric orderer service
  config.vm.network :forwarded_port, guest: 7051, host: 7051 # fabric peer vp0 service
  config.vm.network :forwarded_port, guest: 7053, host: 7053 # fabric peer event service
  config.vm.network :forwarded_port, guest: 7054, host: 7054 # fabric-ca service
  config.vm.network :forwarded_port, guest: 5984, host: 15984 # CouchDB service
  ### Below are probably missing.....
  config.vm.network :forwarded_port, guest: 7056, host: 7056
  config.vm.network :forwarded_port, guest: 7058, host: 7058
  config.vm.network :forwarded_port, guest: 8051, host: 8051
  config.vm.network :forwarded_port, guest: 8053, host: 8053
  config.vm.network :forwarded_port, guest: 8054, host: 8054
  config.vm.network :forwarded_port, guest: 8056, host: 8056
  config.vm.network :forwarded_port, guest: 8058, host: 8058

</code></pre>

<p>Add to your Vagrant file a folder for referencing the sdkintegration folder between the lines below:</p>
<p>在Vagrant文件中，增加SDK集成目录的引用：</p>
<p>config.vm.synced_folder &ldquo;..&rdquo;, &ldquo;/opt/gopath/src/github.com/hyperledger/fabric&rdquo;</br></p>
<p><code>config.vm.synced_folder "/home/&lt;&lt;user&gt;&gt;/fabric-sdk-java/src/test/fixture/sdkintegration", "/opt/gopath/src/github.com/hyperledger/fabric/sdkintegration</code></br></p>
<p>config.vm.synced_folder ENV.fetch(&lsquo;LOCALDEVDIR&rsquo;, &ldquo;..&rdquo;), &ldquo;#{LOCALDEV}&rdquo;</br></p>
<h2 id="sdk-sdk-dependencies">SDK 依赖(SDK dependencies)<a class="headerlink" href="#sdk-sdk-dependencies" title="Permanent link">&para;</a></h2>
<p>SDK depends on few third party libraries that must be included in your classpath when using the JAR file. To get a list of dependencies, refer to pom.xml file or run
当你使用JAR文件时，SDK依赖的第三方库应该包含在classpath中。为了可以得到依赖清单，可以参照pom.xml文件或者运行</p>
<p><code>mvn dependency:tree</code> or <code>mvn dependency:list</code>.
<code>mvn dependency:tree</code> 或 <code>mvn dependency:list</code>.</p>
<p>Alternatively, <code> mvn dependency:analyze-report </code> will produce a report in HTML format in target directory listing all the dependencies in a more readable format.
除此之外，<code> mvn dependency:analyze-report </code> 会在目标目录中生成一个HTML格式的报告更清晰地列出所有的依赖包。</p>
<h2 id="sdkusing-the-sdk">使用SDK(Using the SDK)<a class="headerlink" href="#sdkusing-the-sdk" title="Permanent link">&para;</a></h2>
<p>The SDK&rsquo;s test cases uses chaincode in the SDK&rsquo;s source tree: <code>/src/test/fixture</code>
SDK的测试用例中使用链码源码树： <code>/src/test/fixture</code></p>
<p>The SDK&rsquo;s JAR is in <code>target/fabric-sdk-java-1.0.0-SNAPSHOT.jar</code> and you will need the additional dependencies listed above.
When the SDK is published to <code>Maven</code> you will be able to simply include it in your application&rsquo;s <code>pom.xml</code>.</p>
<p>SDK的JAR包在<code>target/fabric-sdk-java-1.0.0-SNAPSHOT.jar</code>，你可能会需要增加上面提到的附加的依赖包。
当SDK发布到Maven后，你只需要简单的在你的应用的<code>pom.xml</code>包含它。</p>
<p>Add below code in your <code>pom.xml</code> to download fabric-sdk-java-1.0
在你的<code>pom.xml</code>文件增加下面的代码来下载fabric-sdk-java-1.0</p>
<pre><code class="xml">
     &lt;dependencies&gt;
     &lt;dependency&gt;
            &lt;groupId&gt;org.hyperledger.fabric-sdk-java&lt;/groupId&gt;
            &lt;artifactId&gt;fabric-sdk-java&lt;/artifactId&gt;
            &lt;version&gt;1.0.0&lt;/version&gt;
         &lt;/dependency&gt;
     &lt;/dependencies&gt;
</code></pre>

<h3 id="compiling">编译(Compiling)<a class="headerlink" href="#compiling" title="Permanent link">&para;</a></h3>
<p>To build this project, the following dependencies must be met</p>
<ul>
<li>JDK 1.8 or above</li>
<li>Apache Maven</li>
</ul>
<p>为了能够编译该工程，你需要满足以下要求</p>
<ul>
<li>JDK 1.8 或更高</li>
<li>Apache Maven</li>
</ul>
<p>Once your JAVA_HOME points to your installation of JDK 1.8 (or above) and JAVA_HOME/bin and Apache maven are in your PATH, issue the following command to build the jar file:
当你的JAVA_HOME指向了JDK 1.8安装目录，在PATH中设置了JAVA_HOME/bin和 Apache Maven，你可以执行下面的命令来打包jar文件：</p>
<p><code>
  mvn install
</code>
or
<code>
  mvn install -DskipTests
</code> 如果你不想执行单元测试。</p>
<h3 id="running-the-unit-tests">执行单元测试(Running the unit tests)<a class="headerlink" href="#running-the-unit-tests" title="Permanent link">&para;</a></h3>
<p>To run the unit tests, please use <code>mvn test</code> or <code>mvn install</code> which will run the unit tests and build the jar file.You must be running a local peer and orderer to be able to run the unit tests.</p>
<p>通过<code>mvn test</code> 来执行单元测试或 <code>mvn install</code> 执行单元测试并生成jar文件。你必须在本地运行了peer和orderer节点才能执行单元测试。</p>
<h3 id="running-the-integration-tests">执行集成测试(Running the integration tests)<a class="headerlink" href="#running-the-integration-tests" title="Permanent link">&para;</a></h3>
<p>You must be running local instances of Fabric-ca, Fabric peers, and Fabric orderers to be able to run the integration tests. See above for running these services in Vagrant.
Use this <code>maven</code> command to run the integration tests:</p>
<p>你必须在本地运行了Fabric-ca, Fabric peers, and Fabric orderers节点才能够执行集成测试。参照上文中如何在Vagrant中运行这些服务。
使用下面的<code>maven</code>指令来执行集成测试：</p>
<ul>
<li><em>mvn failsafe:integration-test -DskipITs=false</em></li>
</ul>
<h3 id="end-to-end-test-scenario">端到端测试场景(End to end test scenario)<a class="headerlink" href="#end-to-end-test-scenario" title="Permanent link">&para;</a></h3>
<p>The <em>src/test/java/org/hyperledger/fabric/sdkintegration/End2endIT.java</em> integration test is an example of installing, instantiating, invoking and querying a chaincode.
It constructs the Hyperledger channel, deploys the <code>GO</code> chaincode, invokes the chaincode to do a transfer amount operation and queries the resulting blockchain world state.</p>
<p>This test is a reworked version of the Fabric <a href="https://github.com/hyperledger/fabric/tree/master/examples/e2e_cli">e2e_cli example</a> to demonstrate the features of the SDK.
To better understand blockchain and Fabric concepts, we recommend you install and run the <em>e2e_cli</em> example.</p>
<p>_src/test/java/org/hyperledger/fabric/sdkintegration/End2endIT.java_中的集成测试，是一个简单的安装、实例化、调用和查询链码的例子。它构建了Hyperledger通道，发布<code>GO</code>版本链码，调用链码，执行转账动作，并在区块链上查询结果。</p>
<h3 id="end-to-end-test-environment">端到端测试环境(End to end test environment)<a class="headerlink" href="#end-to-end-test-environment" title="Permanent link">&para;</a></h3>
<p>The test defines one Fabric orderer and two organizations (peerOrg1, peerOrg2), each of which has 2 peers, one fabric-ca service.</p>
<p>该测试包含一个orderer节点，两个组织(peerOrg1, peerOrg2)，每个组织各自包含两个节点，以及一个fabric-ca服务。</p>
<h4 id="certificates-and-other-cryptography-artifacts">证书及其他加密工件(Certificates and other cryptography artifacts)<a class="headerlink" href="#certificates-and-other-cryptography-artifacts" title="Permanent link">&para;</a></h4>
<p>Fabric requires that each organization has private keys and certificates for use in signing and verifying messages going to and from clients, peers and orderers.
Each organization groups these artifacts in an <strong>MSP</strong> (Membership Service Provider) with a corresponding unique <em>MSPID</em> .</p>
<p>Furthermore, each organization is assumed to generate these artifacts independently. The <em>fabric-ca</em> project is an example of such a certificate generation service.
Fabric also provides the <code>cryptogen</code> tool to automatically generate all cryptographic artifacts needed for the end to end test.
In the directory src/test/fixture/sdkintegration/e2e-2Orgs/channel</p>
<p>The command used to generate end2end <code>crypto-config</code> artifacts:</br></p>
<p><code>build/bin/cryptogen generate --config crypto-config.yaml --output=crypto-config</code></p>
<p>For ease of assigning ports and mapping of artifacts to physical files, all peers, orderers, and fabric-ca are run as Docker containers controlled via a docker-compose configuration file.</p>
<p>The files used by the end to end are:
 * <em>src/test/fixture/sdkintegration/e2e-2Orgs/channel</em>  (everything needed to bootstrap the orderer and create the channels)
 * <em>src/test/fixture/sdkintegration/e2e-2Orgs/crypto-config</em> (as-is. Used by <code>configtxgen</code> and <code>docker-compose</code> to map the MSP directories)
 * <em>src/test/fixture/sdkintegration/docker-compose.yaml</em></p>
<p>The end to end test case artifacts are stored under the directory <em>src/test/fixture/sdkintegration/e2e-2Org/channel</em> .</p>
<p>Fabric需要每个组织都有自己的私钥和证书，用来签名和验证客户端、节点和orderer之间的消息。
每个组织的这些工件在<strong>MSP</strong> (Membership Service Provider)中都有统一的唯一 <em>MSPID</em>。</p>
<p>而且，我们假设各个组织都是独立的生成这些工件。<em>fabric-ca</em>工程是一个证书生成服务的一个例子。
Fabric同时提供<code>cryptogen</code>工具来自动生成端对端测试所需的加密用的工件。
在src/test/fixture/sdkintegration/e2e-2Orgs/channel目录</p>
<p>使用 <code>crypto-config</code> 命令来生成 end2end 工件：</br>
   <code>build/bin/cryptogen generate --config crypto-config.yaml --output=crypto-config</code></p>
<p>为了方便分配端口和映射这些工件到物理文件，所有的peer， order 和fabric-ca都运行在Docker容器中，通过docker-compose配置文件来控制。</p>
<p>使用到了下面这些文件：
 * <em>src/test/fixture/sdkintegration/e2e-2Orgs/channel</em>  (everything needed to bootstrap the orderer and create the channels)
 * <em>src/test/fixture/sdkintegration/e2e-2Orgs/crypto-config</em> (as-is. Used by <code>configtxgen</code> and <code>docker-compose</code> to map the MSP directories)
 * <em>src/test/fixture/sdkintegration/docker-compose.yaml</em></p>
<p>端对端测试用例工件存储在_src/test/fixture/sdkintegration/e2e-2Org/channel_目录中。</p>
<h3 id="tlsordererpeertls-connection-to-orderer-and-peers">通过TLS连接到Orderer和Peer(TLS connection to Orderer and Peers)<a class="headerlink" href="#tlsordererpeertls-connection-to-orderer-and-peers" title="Permanent link">&para;</a></h3>
<p>IBM Java needs the following properties defined to use TLS 1.2 to get an HTTPS connections to Fabric CA.</p>
<pre><code>-Dcom.ibm.jsse2.overrideDefaultTLS=true   -Dhttps.protocols=TLSv1.2
</code></pre>

<p>We need certificate and key for each of the Orderer and Peers for TLS connection. You can generate your certificate and key files with openssl command as follows:</p>
<ul>
<li>Set up your own Certificate Authority (CA) for issuing certificates</li>
<li>For each of orderers and peers:</li>
<li>generate a private key: <code>openssl genrsa 512 &gt; key.pem</code>.</li>
<li>generate a certificate request (csr): <code>openssl req -new -days 365 -key key.pem -out csr.pem</code>, which will request your input for some information, where CN has to be the container&rsquo;s alias name (e.g. peer0, peer1, etc), all others can be left blank.</li>
<li>sign the csr with the CA private key to generate a certificate: <code>openssl ca -days 365 -in csr.pem -keyfile {CA&rsquo;s privatekey} -notext -out cert.pem</code></li>
<li>put the resulting cert.pem and key.pem together with the CA&rsquo;s certificate (as the name cacert.pem) in the directory where the docker container can access.</li>
</ul>
<p>The option -notext in the last openssl command in the above is important. Without the option, the resulting cert.pemmay does not work for some Java implementation (e.g. IBM JDK).
The certificates and keys for the end-to-end test case are stored in the directory <em>src/test/fixture/sdkintegration/e2e-2Org/tls/</em>.</p>
<p>Currently, the pom.xml is set to use netty-tcnative-boringssl for TLS connection to Orderer and Peers, however, you can change the pom.xml (uncomment a few lines) to use an alternative TLS connection via ALPN.</p>
<p>IBM Java需要以下定义一下参数才能使用TLS 1.2来和Fabric CA建立HTTPS连接。</p>
<pre><code>-Dcom.ibm.jsse2.overrideDefaultTLS=true   -Dhttps.protocols=TLSv1.2
</code></pre>

<p>每个Orderer和Peer建立TLS连接都需要证书和私钥。你可以按以下步骤通过openssl命令来生成证书和私钥文件：
 * 设置你自己的证书认证机构（CA）来发行证书
 * 对每一个Orderer和Peer
    * 生成私钥 <code>openssl genrsa 512 &gt; key.pem</code>。
    * 生成证书请求（csr）<code>openssl req -new -days 365 -key key.pem -out csr.pem</code>，这里可能需要你填写一些信息，CN应该是容器的别名（比如peer0， peer1等），其余的都可以留空
    * 通过CS的私钥来给证书请求（CSR）签名并生成证书：<code>openssl ca -days 365 -in csr.pem -keyfile {CA&rsquo;s privatekey} -notext -out cert.pem</code>
    * 将生成的cert.pem 和 key.pem 同CA的证书(名字cacert.pem)一起放到docker容器可以访问到的目录中。</p>
<p>上面最后一条openssl命令中的 -notext 选项非常重要。没有这个参数的话，生成的cert.pemmay没办法在某些java环境中用（比如java JDK）。
这些证书和钥匙文件放在_src/test/fixture/sdkintegration/e2e-2Org/tls/_目录中。</p>
<p>目前，pom.xml设置使用netty-tcnative-boringssl在Orderer和Peer之间建立TLS连接，你可以更该pom.xml(注释其中一些行)来通过ALPN来使用其他的TLS连接。</p>
<h3 id="chaincode-endorsement-policies">链码背书策略(Chaincode endorsement policies)<a class="headerlink" href="#chaincode-endorsement-policies" title="Permanent link">&para;</a></h3>
<p>Policies are described in the <a href="https://gerrit.hyperledger.org/r/gitweb?p=fabric.git;a=blob;f=docs/endorsement-policies.md;h=1eecf359c12c3f7c1ddc63759a0b5f3141b07f13;hb=HEAD">Fabric Endorsement Policies document</a>.
You create a policy using a Fabric tool ( an example is shown in <a href="https://jira.hyperledger.org/browse/FAB-2376?focusedCommentId=21121&amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-21121">JIRA issue FAB-2376</a>)
and give it to the SDK either as a file or a byte array. The SDK, in turn, will use the policy when it creates chaincode instantiation requests.</p>
<p>To input a policy to the SDK, use the <strong>ChaincodeEndorsementPolicy</strong> class.</p>
<p>For testing purposes, there are 2 policy files in the <em>src/test/resources</em> directory
  * <em>policyBitsAdmin</em> ( which has policy <strong>AND(DEFAULT.admin)</strong> meaning <em>1 signature from the DEFAULT MSP admin&rsquo; is required</em> )
  * <em>policyBitsMember</em> ( which has policy <strong>AND(DEFAULT.member)</strong> meaning <em>1 signature from a member of the DEFAULT MSP is required</em> )</p>
<p>and one file in the <em>src/test/fixture/sdkintegration/e2e-2Orgs/channel</em> directory specifically for use in the end to end test scenario
  * <em>members_from_org1_or_2.policy</em> ( which has policy <strong>OR(peerOrg1.member, peerOrg2.member)</strong> meaning  <em>1 signature from a member of either organizations peerOrg1, PeerOrg2 is required</em>)</p>
<p>Alternatively, you can also use ChaincodeEndorsementPolicy class by giving it a YAML file that has the policy defined in it.
 See examples of this in the End2endIT testcases that use <em>src/test/fixture/sdkintegration/chaincodeendorsementpolicy.yaml</em>
 The file chaincodeendorsementpolicy.yaml has comments that help understand how to create these policies. The first section
 lists all the signature identities you can use in the policy. Currently, only ROLE types are supported.
 The policy section is comprised of <code>n-of</code> and <code>signed-by</code> elements.  Then n-of (<code>1-of</code> <code>2-of</code>) require that many (<code>n</code>) in that
 section to be true. The <code>signed-by</code> references an identity in the identities section.</p>
<p>背书策略在<a href="https://gerrit.hyperledger.org/r/gitweb?p=fabric.git;a=blob;f=docs/endorsement-policies.md;h=1eecf359c12c3f7c1ddc63759a0b5f3141b07f13;hb=HEAD">Fabric Endorsement Policies document</a>上做了详细的阐释。
你可以通过Fabric工具来创建一个策略(在 <a href="https://jira.hyperledger.org/browse/FAB-2376?focusedCommentId=21121&amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-21121">JIRA issue FAB-2376</a> 有个例子)以文件或byte数组方式传给SDK。同时SDK会使用该策略来创建链码初始化请求。</p>
<p>使用<strong>ChaincodeEndorsementPolicy</strong>类将策略传给SDK。
为了测试目的，在_src/test/resources_下有两个策略文件。
  * <em>policyBitsAdmin</em> ( 包含 <strong>AND(DEFAULT.admin)</strong> 策略， <em>需要一个DEFAULT MSP 管理员的签名</em> )
  * <em>policyBitsMember</em> ( 包含 <strong>AND(DEFAULT.member)</strong> 策略， <em>需要一个DEFAULT MSP 成员的签名</em> )</p>
<p>在_src/test/fixture/sdkintegration/e2e-2Orgs/channel_下油一个文件，指定了端对端的测试场景
  * <em>members_from_org1_or_2.policy</em> ( 包含 <strong>OR(peerOrg1.member, peerOrg2.member)</strong> 策略  <em>需要任一组织(peerOrg1, PeerOrg2)下成员的签名</em>)</p>
<p>另外，你也可以用ChaincodeEndorsementPolicy类，通过给他指定一个包含策略定义的YAML文件来实现。
参照_src/test/fixture/sdkintegration/chaincodeendorsementpolicy.yaml_目录下End2endIT测试用例。 
文件chaincodeendorsementpolicy.yaml中，有一些帮助理解如何创建策略的注释。第一部分列出了所有可以在策略中使用的签名。当前只支持ROLE类型。
policy区块包含<code>n-of</code> 和 <code>signed-by</code> 元素。n-of (<code>1-of</code> <code>2-of</code>) 元素需要在这个区块中将“many” (<code>n</code>) 设置为 true. <code>signed-by</code>元素引用了在identities区块的身份信息。</p>
<h3 id="channel-creation-artifacts">通道创建工件(Channel creation artifacts)<a class="headerlink" href="#channel-creation-artifacts" title="Permanent link">&para;</a></h3>
<p>Channel configuration files and orderer bootstrap files ( see directory <em>src/test/fixture/sdkintegration/e2e-2Orgs/channel</em> ) are needed when creating a new channel.
This is created with the Hyperledger Fabric <code>configtxgen</code> tool.</p>
<p>For End2endIT.java the commands are</p>
<ul>
<li>build/bin/configtxgen -outputCreateChannelTx foo.tx -profile TwoOrgsChannel -channelID foo</li>
<li>build/bin/configtxgen -outputCreateChannelTx bar.tx -profile TwoOrgsChannel -channelID bar</li>
<li>build/bin/configtxgen -outputBlock orderer.block -profile TwoOrgsOrdererGenesis</li>
</ul>
<p>with the configtxgen config file <em>src/test/fixture/sdkintegration/e2e-2Orgs/channel/configtx.yaml</em></p>
<p>If <code>build/bin/configtxgen</code> tool is not present  run <code>make configtxgen</code></p>
<p>Before running the end to end test case:
 *  you may need to modify <code>configtx.yaml</code> to change all hostname and port definitions to match
your server(s) hostname(s) and port(s).
 *  you <strong>WILL</strong> have to modify <code>configtx.yaml</code> to have the <em>MSPDir</em> point to the correct path to the <em>crypto-config</em> directories.
   * <code>configtx.yaml</code> currently assumes that you are running in a Vagrant environment where the fabric, fabric-ca and fabric-sdk-java projects exist under the <em>/opt/gopath/src/github.com/hyperledger</em> directory.</p>
<p>创建通道的时候，需要有通道的配置文件以及orderer引导文件（在_src/test/fixture/sdkintegration/e2e-2Orgs/channel_目录下）。
这个配置文件是通过<code>configtxgen</code>来创建的。</p>
<p>对于End2endIT.java类来说，命令是：
 * build/bin/configtxgen -outputCreateChannelTx foo.tx -profile TwoOrgsChannel -channelID foo
 * build/bin/configtxgen -outputCreateChannelTx bar.tx -profile TwoOrgsChannel -channelID bar
 * build/bin/configtxgen -outputBlock orderer.block -profile TwoOrgsOrdererGenesis</p>
<p>配置文件是  <em>src/test/fixture/sdkintegration/e2e-2Orgs/channel/configtx.yaml</em>。</p>
<p>如果<code>build/bin/configtxgen</code>工具不存在，则需要执行<code>make configtxgen</code>来生成。</p>
<p>在你运行端对端测试用例前：
<em> 你需要修改<code>configtx.yaml</code>文件，将主机名和端口定义修改成你服务器真实的主机名和端口。
</em> 你将会需要修改<code>configtx.yaml</code>文件，将_MSPDir_指向到正确的_crypto-config_目录。
  * <code>configtx.yaml</code>文件当前假设你运行在Vagrant环境，而且fabric、fabric-ca 和fabric-sdk-java 在_/opt/gopath/src/github.com/hyperledger_目录下。</p>
<h3 id="gogo-lang-chaincode">GO语言链码(GO Lang chaincode)<a class="headerlink" href="#gogo-lang-chaincode" title="Permanent link">&para;</a></h3>
<p>Go lang chaincode dependencies must be contained in vendor folder.
 For an explanation of this see <a href="https://blog.gopheracademy.com/advent-2015/vendor-folder/">Vender folder explanation</a></p>
<p>Go语言链码的依赖文件必须包含在vendor目录下。
详细解释参照<a href="https://blog.gopheracademy.com/advent-2015/vendor-folder/">Vender folder explanation</a></p>
<h2 id="basic-troubleshooting">简单的问题解决(Basic Troubleshooting)<a class="headerlink" href="#basic-troubleshooting" title="Permanent link">&para;</a></h2>
<p><strong>identity or token do not match</strong></p>
<p>Keep in mind that you can perform the enrollment process with the membership services server only once, as the enrollmentSecret is a one-time-use password. If you have performed a FSUser registration/enrollment with the membership services and subsequently deleted the crypto tokens stored on the client side, the next time you try to enroll, errors similar to the ones below will be seen.</p>
<p><code>Error: identity or token do not match</code></p>
<p><code>Error: FSUser is already registered</code></p>
<p>To address this, remove any stored crypto material from the CA server by following the instructions <a href="https://github.com/hyperledger/fabric/blob/master/docs/Setup/Chaincode-setup.md#removing-temporary-files-when-security-is-enabled">here</a> which typically involves deleting the /var/hyperledger/production directory and restarting the membership services. You will also need to remove any of the crypto tokens stored on the client side by deleting the KeyValStore . That KeyValStore is configurable and is set to ${FSUser.home}/test.properties within the unit tests.</p>
<p>When running the unit tests, you will always need to clean the membership services database and delete the KeyValStore file, otherwise, the unit tests will fail.</p>
<p>记住你只能运行成员服务的登记进程（enrollment process）一次，因为enrollmentSecret是一次性密码。如果你已经执行过一次FSUser registration/enrollment，然后删除了加密存储在客户端的token后，下一次enroll的时候，就会出现下面类似的问题：
<code>Error: identity or token do not match</code></p>
<p><code>Error: FSUser is already registered</code></p>
<p>为了解决这个问题，请参照<a href="https://github.com/hyperledger/fabric/blob/master/docs/Setup/Chaincode-setup.md#removing-temporary-files-when-security-is-enabled">here</a> 删除所有存储在CA服务器上的的加密文件，文件目录在/var/hyperledger/production，然后重启成员服务。同时你还需要通过删除KeyValStore来清楚客户端所有的加密token。KeyValStore是可配置的，参照${FSUser.home}/test.properties文件。</p>
<p>当运行测试用例时，你需要清理成员服务器数据库并删除KeyValStore文件，否则单元测试会失败。</p>
<p><strong>java.security.InvalidKeyException: Illegal key size</strong></p>
<p>If you get this error, this means your JDK does not capable of handling unlimited strength crypto algorithms. To fix this issue, You will need to download the JCE libraries for your version of JDK. Please follow the instructions <a href="http://stackoverflow.com/questions/6481627/java-security-illegal-key-size-or-default-parameters">here</a> to download and install the JCE for your version of the JDK.</p>
<p>如果你碰到这个问题，就是你的JDK不支持无限长度加密逻辑。要修复这个问题，你需要下载正对你JDK版本的JCE库，请参照<a href="http://stackoverflow.com/questions/6481627/java-security-illegal-key-size-or-default-parameters">这里</a>来下载和安装JCE库。</p>
<h2 id="communicating-with-developers-and-fellow-users">和开发者交流(Communicating with developers and fellow users)<a class="headerlink" href="#communicating-with-developers-and-fellow-users" title="Permanent link">&para;</a></h2>
<p>Sign into <a href="https://chat.hyperledger.org/">Hyperledger project&rsquo;s Rocket chat</a>
 For this you will also need a <a href="https://identity.linuxfoundation.org/">Linux Foundation ID</a></p>
<p>Join the <b>fabric-sdk-java</b> channel.</p>
<p>登录<a href="https://chat.hyperledger.org/">Hyperledger project&rsquo;s Rocket chat</a>。你需要一个<a href="https://identity.linuxfoundation.org/">Linux Foundation ID</a>。 然后加入<b>fabric-sdk-java</b>频道。</p>
<h2 id="reporting-issues">报告问题(Reporting Issues)<a class="headerlink" href="#reporting-issues" title="Permanent link">&para;</a></h2>
<p>If your issue is with building Fabric development environment please discuss this on rocket.chat&rsquo;s #fabric-dev-env channel.
如果你有编译Fabric开发环境的问题，请在rocket.chat的 #fabric-dev-env channel讨论。</p>
<p>To report an issue please use: <a href="http://jira.hyperledger.org/">Hyperledger&rsquo;s JIRA</a>.
To login you will need a Linux Foundation ID (LFID) which you get at <a href="https://identity.linuxfoundation.org/">The Linux Foundation</a>
if you don&rsquo;t already have one.</p>
<p>报告问题请使用JIRA：<a href="http://jira.hyperledger.org/">Hyperledger&rsquo;s JIRA</a>。
你需要使用Linux基金会ID(LFID)来登录，如果没有，可以在<a href="https://identity.linuxfoundation.org/">The Linux Foundation</a>注册一个。</p>
<p>JIRA Fields should be:
<dl>
  <dt>Type</dt>
  <dd>Bug <i>or</i> New Feature</dd></p>
<p><dt>Component</dt>
  <dd>fabric-sdk-java</dd>
  <dt>Fix Versions</dt>
    <dd>v1.0.1</dd>
</dl></p>
<p>Pleases provide as much information that you can with the issue you&rsquo;re experiencing: stack traces logs.</p>
<p>Please provide the output of <strong>java -XshowSettings:properties -version</strong></p>
<p>Logging for the SDK can be enabled with setting environment variables:</p>
<p>ORG_HYPERLEDGER_FABRIC_SDK_LOGLEVEL=TRACE</p>
<p>ORG_HYPERLEDGER_FABRIC_CA_SDK_LOGLEVEL=TRACE</p>
<p>Fabric debug is by default enabled in the SDK docker-compose.yaml file with</p>
<p>On Orderer:</p>
<p>ORDERER_GENERAL_LOGLEVEL=debug</p>
<p>On peers:
CORE_LOGGING_LEVEL=DEBUG</p>
<p>Fabric CA
by starting command have the -d parameter.</p>
<p>Upload full logs to the JIRA not just where the issue occurred if possible</p>
<p>请提供尽量多的信息，比如堆栈跟踪记录。
请提供 <strong>java -XshowSettings:properties -version</strong> 命令的输出结果
可能的话，请上传当问题发生时完整的日志。</p>
<p><a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../kafka_zh/" class="btn btn-neutral float-right" title="基于kafka的排序服务">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../sdk_node_zh/" class="btn btn-neutral" title="SDK--node"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
      <p>Hyperledger国际化工作组(yls@chainnova.com)</p>
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>
    
  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/HyperledgerCN/hyperledgerDocs" class="fa fa-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href="../sdk_node_zh/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../kafka_zh/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script src="../js/theme.js"></script>

</body>
</html>
